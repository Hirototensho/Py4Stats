# Project Guide

## Py4Stats ライブラリのモジュール構成

```python
py4stats
├ メインモジュール               # Import py4stats で直接読み込み
│ ├ eda_tools                   # 探索的データ解析と前処理
│ │ ├ _.nw                         # narwhals ベースの現行実装
│ │ └ _.pandas                     # Pandas ベースの旧実装（廃止予定）
│ └ regression_tools            # 回帰分析の可視化と表作成
└ サブモジュール                 # Import py4stats では読み込まれない
　 ├ heckit_helper               #regression_tools の追加メソッド
　 └ building_block              # 内部実装用のアサーション関数とユーティリティ関数を提供
 ```

## Py4Stats ライブラリのインポート

``` python
# ライブラリの読み込み（推奨）
import py4stats as py4st

# サブモジュールの読み込み
from py4stats import heckit_helper
from py4stats import building_block as build 

# eda_tools のバックエンド別実装の明示的な読み込み
from py4stats.eda_tools import _nw as eda_nw
from py4stats.eda_tools import _pandas as eda_pd
```

## リポジトリのディレクトリ構成
2026年1月24日 現在

``` python
Py4Stats 
├── README.md                           # GitHub リポジトリのトップページ用ファイル
├── index.qmd                           # APIドキュメント(Quarto Book)のトップページ
├── _quarto.yml                         # Quarto Book の設定ファイル
├── introduction.qmd
├── articles                            # APIドキュメント以外の公開記事
├── man                                 # APIドキュメントのうち、関数のドキュメント
│   ├── diagnose.qmd
│   ├── compare_ols.qmd
│   ...
│   └── image                           # ドキュメントに使用する画像
├── py4stats
│   ├── __init__.py                     # Py4Stats の Import 時に読み込まれる関数を定義
│   ├── building_block.py               # 引数のアサーションなどユーティリティモジュール
│   ├── eda_tools                       # 探索的データ解析
│   │   ├── __init__.py
│   │   ├── _nw.py                      # バックエンドに narwhals を使用した実装
│   │   └── _pandas.py                  # バックエンドに pandas を使用した旧仕様
│   ├── heckit_helper.py
│   └── regression_tools.py             # 回帰分析の可視化と作表
├── pyproject.toml
├── reference.md                        # man/ の関数ドキュメントへのリンク集
├── setup.ipynb
├── setup.py
└── tests                              # APIのテストコード
    ├── fixtures                       # 自動テストで参照するデータ
    ├── test_building_block.py
    ├── test_eda_tools_nw.py
    ├── test_eda_tools_pandas.py
    ├── test_heckit_helper.py
    └── test_regression_tools.py
```

**注意**：`eda_tools._pandas.py` は 非推奨扱いで将来的に廃止する予定です。詳細は以下を参照してください。

- [Technical Notes](./narwhals_in_py4stats.qmd)
- [eda_tools開発状況](./eda_tools_development_status.qmd)

## リポジトリの運用方針

![Py4Statsリポジトリの運用方針](./image/Py4Statsリポジトリの運用方針.png)

## セマンティック バージョニングについてのメモ

Py4Stats ライブラリのバージョンは次の方式のセマンティック バージョニングで管理します(e.g. `v 0.1.0`)。

    v MAJOR.MINOR.PATCH

`v MAJOR.MINOR.PATCH` の各要素は、次の規則で更新します。

1. `MAJOR` APIの変更に互換性のない場合はメジャーバージョンを上げる
2. `MINOR` 後方互換性があり機能性を追加した場合はマイナーバージョンを上げる
3. `PATCH` 後方互換性を伴うバグ修正をした場合はパッチバージョンを上げる

## デザインパターン

### 引数のアサーション

```python
from py4stats import building_block as build 
# 文字列引数のアサーション（選択肢を制限）
arg = build.arg_match(
    arg, values = ['option_1', 'option_2'], 
    arg_name = 'arg', 
    )
```

```python
build.assert_logical(arg, arg_name = 'arg')   # ブール値
build.assert_character(arg, arg_name = 'arg') # 文字列
build.assert_numeric(arg, arg_name = 'arg')   # 数値(int or float)
build.assert_integer(arg, arg_name = 'arg')   # 整数値(int)
build.assert_count(arg, arg_name = 'arg')     # 非負整数値(int)
build.assert_float(arg, arg_name = 'arg')     # フロート値(float)
```

### narwhals が受け入れ可能な互換オブジェクトに `singledispatch` する方法

#### 結論

- DataFrame の場合 `@foo.register(nw.typing.IntoDataFrame)` を使う
- Series の場合 `@foo.register(nw.typing.IntoSeries)` を使う

#### 詳細

`functools.singledispatch` を使って総称関数を定義する場合、`@singledispatch` デコレータで総称関数を定義したあと、`@foo.register(Class)` デコレータでクラス毎のメソッド関数を定義します。

narwhals が受け入れ可能な DataFrame 互換オブジェクトに対するメソッドを定義する場合には、`nw.typing.IntoDataFrame` を使い、Series 互換オブジェクトに対するメソッドを定義する場合には `nw.typing.IntoSeries` を使います。

``` python
# 実装例
import narwhals as nw
from functools import singledispatch

@singledispatch
def foo(x):
    return 'I am some object'

@foo.register(nw.typing.IntoDataFrame)
def foo_df(x):
    return  'I am a DataFrame'

@foo.register(nw.typing.IntoSeries)
def foo_s(x):
    return 'I am a Series'
```


``` python
# 動作例
import pandas as pd
import polars as pl
import pyarrow as pa

data_pd = pd.DataFrame({'x':[1, 2, 3], 'y':['a', 'b', 'c']})
data_pl = pl.from_pandas(data_pd)
data_pa = pa.Table.from_pandas(data_pd)
data_nw = nw.from_native(data_pd)

data_dict = {
    'df_pd' :data_pd, 'df_pl' :data_pl, 'df_pa' :data_pa, 'df_nw' :data_nw,
    's_pd' :data_pd['x'], 's_pl' :data_pl['x'], 's_pa' :data_pa['x'], 's_nw':data_nw['x'],
    'int': 1 
}

[f"{k}: {foo(x)}" for k, x in zip(data_dict.keys(), data_dict.values())]
#> ["df_pd: 'I am a DataFrame'",
#>  "df_pl: 'I am a DataFrame'",
#>  "df_pa: 'I am a DataFrame'",
#>  "df_nw: 'I am a DataFrame'",
#>  "s_pd: 'I am a Series'",
#>  "s_pl: 'I am a Series'",
#>  "s_pa: 'I am a Series'",
#>  "s_nw: 'I am a Series'",
#>  "int: 'I am some object'"]
```

## 総称関数の実装に関する覚書

### 総称関数に登録されたメソッドの確認

#### 結論

- ある関数に登録されたメソッド全体を確認するには `foo.registry` を使い
- ある関数に登録された特定のクラスのメソッドを確認するには `foo.dispatch(Class)` を使います

#### 詳細

ある総称関数に、どのようなメソッドが登録されているかは、`.registry` 属性で確認することができます。`.registry` は `{型: 実装関数}` の辞書であり、`object` クラスはデフォルト実装に対応しています。


``` python
import py4stats as py4st
import pandas as pd

registry = py4st.is_dummy.registry
print(pd.Series(registry).apply(lambda x: x.__name__))
#> <class 'object'>                                         is_dummy
#> <class 'narwhals._native.NativeSeries'>           is_dummy_series
#> <class 'narwhals.series.Series'>                  is_dummy_series
#> <class 'narwhals._native.NativeDataFrame'>    is_dummy_data_frame
#> <class 'narwhals.dataframe.DataFrame'>        is_dummy_data_frame
#> <class 'tuple'>                                     is_dummy_list
#> <class 'list'>                                      is_dummy_list
#> dtype: object
```

また、`.dispatch(Class)` メソッドで特定のオブジェクトクラスに対して実装されたメソッド関数を確認することができます。

``` python
print(py4st.is_dummy.dispatch(pd.DataFrame).__name__)
#> is_dummy_data_frame

print(py4st.is_dummy.dispatch(pd.Series).__name__)
#> is_dummy_series

print(py4st.is_dummy.dispatch(list).__name__)
#> is_dummy_list

print(py4st.is_dummy.dispatch(int).__name__) # デフォルト実装
#> is_dummy
```